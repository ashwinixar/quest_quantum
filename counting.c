/*
*************************************************
*	About: The code implements Quantum Counting	*
*	Usage: Run in command prompt "counting.exe"	*
*	Author: Ashwini Kumar Malviya				*
*	Email: ashwinixar@gmail.com					*
*************************************************
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "QuEST.h"

int main (int narg, char *varg[])
{
	//Oracle evaluation results of "E(x) XOR E(x XOR Delta_in) = Delta_out"
	//Delta_in is 0x40 and Delta_out is 0x0E
	//Each index in array is "x" and corresponding entry is oracle evaluation result
	int oracle_e[256] = {	0x38,0x51,0x78,0xF2,0xB2,0x9E,0xD8,0xE,0xB,0xB8,0xE,0xA2,0x84,0xE8,0xE4,0x84,
							0x26,0x63,0x70,0xF2,0x43,0x8A,0x98,0xD1,0xEC,0xB0,0xF7,0x30,0xC6,0xB0,0x81,0x2B,
							0x32,0x33,0x18,0x51,0x8C,0x2E,0xD8,0xCA,0xED,0xE8,0x43,0x19,0x8B,0x25,0xE1,0x8B,
							0xDD,0xFD,0x3B,0x11,0xFB,0x63,0xB3,0x2B,0xD6,0x27,0x3D,0xBE,0x7B,0x5A,0xEB,0xDB,
							0x38,0x51,0x78,0xF2,0xB2,0x9E,0xD8,0xE,0xB,0xB8,0xE,0xA2,0x84,0xE8,0xE4,0x84,
							0x26,0x63,0x70,0xF2,0x43,0x8A,0x98,0xD1,0xEC,0xB0,0xF7,0x30,0xC6,0xB0,0x81,0x2B,
							0x32,0x33,0x18,0x51,0x8C,0x2E,0xD8,0xCA,0xED,0xE8,0x43,0x19,0x8B,0x25,0xE1,0x8B,
							0xDD,0xFD,0x3B,0x11,0xFB,0x63,0xB3,0x2B,0xD6,0x27,0x3D,0xBE,0x7B,0x5A,0xEB,0xDB,
							0x89,0x23,0x54,0x1C,0x64,0x82,0x71,0x21,0xCD,0xA3,0x35,0xF8,0x5E,0x3A,0x14,0xE4,
							0xEF,0x34,0xE0,0xBD,0x4C,0x1F,0x3B,0x55,0x88,0x8C,0x52,0x99,0x95,0x7C,0xBC,0x46,
							0x4E,0x88,0xFC,0x34,0xC6,0x2C,0x31,0x9D,0xD5,0x65,0x1D,0xDC,0x65,0x5F,0x92,0x95,
							0x2A,0x63,0x7B,0xFD,0x47,0x86,0x98,0xD3,0xEC,0xBB,0xF3,0x3C,0xCA,0xBD,0x8A,0x20,
							0x89,0x23,0x54,0x1C,0x64,0x82,0x71,0x21,0xCD,0xA3,0x35,0xF8,0x5E,0x3A,0x14,0xE4,
							0xEF,0x34,0xE0,0xBD,0x4C,0x1F,0x3B,0x55,0x88,0x8C,0x52,0x99,0x95,0x7C,0xBC,0x46,
							0x4E,0x88,0xFC,0x34,0xC6,0x2C,0x31,0x9D,0xD5,0x65,0x1D,0xDC,0x65,0x5F,0x92,0x95,
							0x2A,0x63,0x7B,0xFD,0x47,0x86,0x98,0xD3,0xEC,0xBB,0xF3,0x3C,0xCA,0xBD,0x8A,0x20 };

    QuESTEnv env = createQuESTEnv();

    //Value of Pi
    const double pi = 3.14;

    //"p" represents the precision qubits and "n" represents the block size
    //"P = 2^p" and "N = 2^n"
    const int p = 8, P = 256;
    const int n = 8, N = 256;
    Qureg qubits = createQureg((p + n), env);
    initZeroState(qubits);
    reportQuregParams(qubits);
    reportQuESTEnv(env);

    //Unitary matrix creation corresponding to the "oracle_e"
	ComplexMatrixN e = createComplexMatrixN(8);
    for(int i = 0; i < 256; i++)
    {
    	if(oracle_e[i] == 0xE) e.real[i][i] = -1;
    	else e.real[i][i] = 1;
    }

    //Apply Hadamard on all the (p + n)-qubits to create superposition
    //Here each element in last n-qubit superposition is considered to represent "x" 
    for(int i = 0; i < (p + n); i++)
        hadamard(qubits, i);
    
    //Target qubits on which grover's search must be performed to count the number of correct result
    int targs[n];
    for(int i = 0; i < n; i++)
    	targs[i] = p + i;

    //Applying controlled grover's operator
    int iterations = 1;
    for(int gi = p - 1; gi >= 0; gi--)
    {
    	int ctrls[] = { gi };
    	for(int j = 0; j < iterations; j++)
    	{
    		//Marking
	    	multiControlledMultiQubitUnitary(qubits, ctrls, 1, targs, n, e);
	    	
	        //Diffusion
	        for(int i = p; i < (n + p); i++)
	            hadamard(qubits, i);
	        for(int i = p; i < (n + p); i++)
	            pauliX(qubits, i);
	        multiControlledPhaseFlip(qubits, targs, n);
	        for(int i = p; i < (n + p); i++)
	            pauliX(qubits, i);
	        for(int i = p; i < (n + p); i++)
	            hadamard(qubits, i);
    	}
    	iterations *= 2;
    }
	
    //Inverse QFT on the first p-qubits
    for(int i = 0; i < p; i++)
    {
    	for(int j = 0; j < i; j++)
    	{
    		qreal angle = -2.0 * pi / (pow(2, i - j + 1));
    		controlledPhaseShift(qubits, j, i, angle);
    	}
    	hadamard(qubits, i);
    }
    

    printf("\nCircuit output:\n");
    //Measures the qubits to get the value of first p-qubits
    qreal prob = 0, max_prob = 0;
    int p_val = 0;
    for(int i = 0; i < P; i++)
    {
    	prob = getProbAmp(qubits, i);
    	if(prob > max_prob)
    	{
    		max_prob = prob;
    		p_val = i;
    	}
    }

	//Print (f_tilde) and Approximate count
    if(p_val > (P / 2)) p_val = P - p_val;
    printf("\nThe measured value of (f_tilde) is %d", p_val);
    printf("\nThe approximate count of the correct answers is: %f\n", (N * pow(sin(p_val * pi / P), 2)));

    destroyQureg(qubits, env);
    destroyComplexMatrixN(e);
    destroyQuESTEnv(env);

    return 0;
}