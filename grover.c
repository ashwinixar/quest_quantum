/*
*****************************************************
*	About: The code implements Algorithm 1			*
*	Usage: Run in command prompt "A1.exe <times>"	*
*	<times> must be a positive integer which		*
*	denotes the number of times	grover's operator	*
*	must be repeated								*
*	Example: A1.exe 20								*
*	Author: Ashwini Kumar Malviya					*
*	Email: ashwinixar@gmail.com						*
*****************************************************
*/

#include <stdio.h>
#include <stdlib.h>
#include "QuEST.h"

int main (int narg, char *varg[])
{
	int times = 1;
	if(narg == 2) times = atoi(varg[1]);

	//Oracle evaluation results of "E(x) XOR E(x XOR Delta_in) = Delta_out"
	//Delta_in is 0x40 and Delta_out is 0x0E
	//Each index in array is "x" and corresponding entry is oracle evaluation result
	int oracle_e[256] = {	0x38,0x51,0x78,0xF2,0xB2,0x9E,0xD8,0xE,0xB,0xB8,0xE,0xA2,0x84,0xE8,0xE4,0x84,
							0x26,0x63,0x70,0xF2,0x43,0x8A,0x98,0xD1,0xEC,0xB0,0xF7,0x30,0xC6,0xB0,0x81,0x2B,
							0x32,0x33,0x18,0x51,0x8C,0x2E,0xD8,0xCA,0xED,0xE8,0x43,0x19,0x8B,0x25,0xE1,0x8B,
							0xDD,0xFD,0x3B,0x11,0xFB,0x63,0xB3,0x2B,0xD6,0x27,0x3D,0xBE,0x7B,0x5A,0xEB,0xDB,
							0x38,0x51,0x78,0xF2,0xB2,0x9E,0xD8,0xE,0xB,0xB8,0xE,0xA2,0x84,0xE8,0xE4,0x84,
							0x26,0x63,0x70,0xF2,0x43,0x8A,0x98,0xD1,0xEC,0xB0,0xF7,0x30,0xC6,0xB0,0x81,0x2B,
							0x32,0x33,0x18,0x51,0x8C,0x2E,0xD8,0xCA,0xED,0xE8,0x43,0x19,0x8B,0x25,0xE1,0x8B,
							0xDD,0xFD,0x3B,0x11,0xFB,0x63,0xB3,0x2B,0xD6,0x27,0x3D,0xBE,0x7B,0x5A,0xEB,0xDB,
							0x89,0x23,0x54,0x1C,0x64,0x82,0x71,0x21,0xCD,0xA3,0x35,0xF8,0x5E,0x3A,0x14,0xE4,
							0xEF,0x34,0xE0,0xBD,0x4C,0x1F,0x3B,0x55,0x88,0x8C,0x52,0x99,0x95,0x7C,0xBC,0x46,
							0x4E,0x88,0xFC,0x34,0xC6,0x2C,0x31,0x9D,0xD5,0x65,0x1D,0xDC,0x65,0x5F,0x92,0x95,
							0x2A,0x63,0x7B,0xFD,0x47,0x86,0x98,0xD3,0xEC,0xBB,0xF3,0x3C,0xCA,0xBD,0x8A,0x20,
							0x89,0x23,0x54,0x1C,0x64,0x82,0x71,0x21,0xCD,0xA3,0x35,0xF8,0x5E,0x3A,0x14,0xE4,
							0xEF,0x34,0xE0,0xBD,0x4C,0x1F,0x3B,0x55,0x88,0x8C,0x52,0x99,0x95,0x7C,0xBC,0x46,
							0x4E,0x88,0xFC,0x34,0xC6,0x2C,0x31,0x9D,0xD5,0x65,0x1D,0xDC,0x65,0x5F,0x92,0x95,
							0x2A,0x63,0x7B,0xFD,0x47,0x86,0x98,0xD3,0xEC,0xBB,0xF3,0x3C,0xCA,0xBD,0x8A,0x20 };

    QuESTEnv env = createQuESTEnv();

    Qureg qubits = createQureg(8, env);
    initZeroState(qubits);
    reportQuregParams(qubits);
    reportQuESTEnv(env);

    //Unitary matrix creation corresponding to the "oracle_e"
	ComplexMatrixN e = createComplexMatrixN(8);
    for(int i = 0; i < 256; i++)
    {
    	if(oracle_e[i] == 0xE) e.real[i][i] = -1;
    	else e.real[i][i] = 1;
    }

    //Apply Hadamard on all the n-qubits to create superposition
    //Here each element in superposition is considered to represent "x" 
    for(int i = 0; i < 8; i++)
        hadamard(qubits, i);
    
    int targs[] = { 0,1,2,3,4,5,6,7 };
    printf("\nRunning Grover's operator %d times\n", times);
    for(int gi = 0; gi < times; gi++)
    {
    	//Marking
    	multiQubitUnitary(qubits, targs, 8, e);
    	
        //Diffusion
        for(int i = 0; i < 8; i++)
            hadamard(qubits, i);
        for(int i = 0; i < 8; i++)
            pauliX(qubits, i);
        multiControlledPhaseFlip(qubits, targs, 8);
        for(int i = 0; i < 8; i++)
            pauliX(qubits, i);
        for(int i = 0; i < 8; i++)
            hadamard(qubits, i);
    }
	
    printf("\nCircuit output:\n");

    qreal prob;
    for(int i = 0; i < 256; i++)
    {
    	prob = getProbAmp(qubits, i);
    	printf("Probability amplitude of %02X: %f\n", i, prob);
    }

    destroyQureg(qubits, env);
    destroyComplexMatrixN(e);
    destroyQuESTEnv(env);

    return 0;
}
